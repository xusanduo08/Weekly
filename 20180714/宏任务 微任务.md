### 宏任务和微任务

[原文链接](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

（译者：第一段是废话，不译）

如果你更喜欢看视频的话，这里有[Philip Roberts](https://twitter.com/philip_roberts)讲述的一个[视频](https://vimeo.com/96425312)----视频里并没有讲微任务，但对宏任务、队列和调度进行了很棒的介绍。好了，话不多说，开始我们的旅程...

先看一段小代码：

```javascript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout')
}, 0);

Promise.resolve().then(function(){
  console.log('promise1');
}).then(function() {
  console.log('promise2');
})

console.log('script end');
```

#### 上面代码执行的结果输出顺序是什么？

正确答案是：`script start`,`script end`,`promise1`,`promise2`,`setTimeout`。

事实不同浏览器有不同的结果。Edge，Firefox 40， iOS Safari和desktop Safari 8.0.8输出的结果中，`setTimeout`先于`promise1`和`promise2`输出，而在Firefox 39和Safari 8.0.7中输出结果又是正常的。

#### 输出顺序为什么是这样的？

要知道为什么首先要知道js中事件循环（event loop）是如何处理宏任务和微任务的。如果你是第一次知道这些概念，那么你可能会觉得有些难以理解，不过别怕，深呼吸，发车。。。。

每个进程都有自己的“事件循环”，浏览器的每个页签也都是一个进程，所以它们可以独立运行。在同一个页面中的程序分享着同一个事件循环，它们因此能够同步的进行交流。事件循环持续不断的运行，会不断执行存在于任务队列中的任务。一个事件循环有多个任务源，这些任务源被执行时都有一定的顺序。对于浏览器来讲，浏览器需要决定每次循环时任务从哪个任务源中取，这使得浏览器能够给予视觉敏感的任务一些优先权，比如用户输入。好，各位跟紧了。。。

