### 宏任务和微任务

[原文链接](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

（译者：第一段是废话，不译）

如果你更喜欢看视频的话，这里有[Philip Roberts](https://twitter.com/philip_roberts)讲述的一个[视频](https://vimeo.com/96425312)----视频里并没有讲微任务，但对宏任务、队列和调度进行了很棒的介绍。好了，话不多说，开始我们的旅程...

先看一段小代码：

```javascript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout')
}, 0);

Promise.resolve().then(function(){
  console.log('promise1');
}).then(function() {
  console.log('promise2');
})

console.log('script end');
```

#### 上面代码执行的结果输出顺序是什么？

正确答案是：`script start`,`script end`,`promise1`,`promise2`,`setTimeout`。

事实不同浏览器有不同的结果。Edge，Firefox 40， iOS Safari和desktop Safari 8.0.8输出的结果中，`setTimeout`先于`promise1`和`promise2`输出，而在Firefox 39和Safari 8.0.7中输出结果又是正常的。

#### 为什么是这样的？

要知道为什么首先要知道事件循环（event loop）是如何处理宏任务和微任务的。如果你是第一次知道这些概念，那么你可能会觉得有些难以理解，不过别怕，深呼吸，发车。。。。

每个进程都有自己的“事件循环”，包括web worker在内也是，所以它们可以独立运行。在同一个页面中的程序共享着同一个事件循环，它们因此能够同步的进行交流。事件循环持续的运行，不断执行存在于任务队列中的任务。一个事件循环有多个任务源，一个任务源就是包含多个任务的列表，根据列表中任务的顺序，来调度任务。对于浏览器来讲，浏览器需要决定每次循环时任务从哪个任务源中取，这使得浏览器能够给予视觉敏感的任务一些优先权，比如用户输入。好，各位跟紧了。。。

宏任务可以被调度，所以浏览器可以把宏任务按照一定的顺序的放到js作用域或者DOM中去执行。在执行任务中间，浏览器可能会去更新页面。从鼠标点击到事件回调被执行，这需要一个宏任务来完成，比如渲染HTML，或者上面例子中的`setTimeout`。

`setTimeout`会等待一个延迟时间，然后再去调度包含它回调的宏任务来执行。所以上面例子中，`setTimeout`会比`script end`后输出。`script end`的输出与`setTimeout`回调的执行不属于同一任务。

微任务（microtasks）通常指那些应当在当前执行的脚本执行完毕后（当js执行栈为空时）执行的任务，比如一系列动作的响应，或者没有副作用的异步回调。在宏任务执行结束，没有其他js代码在执行时，微任务队列中的任务就会被处理。在微任务处理过程中加入的其他微任务会被放到队列尾部，并且也会一起被处理。微任务包括 mutaion observer回调（MutaionObserver用来观察节点的变化的），还有比如上面例子中的promise回调。

一个promise被创建后，就会为自己的回调设置一个微任务放到微任务队列中，这确保了它的回调是被异步执行的。所以在一个promise后面调用`.then(yey,nay)`会立即向微任务队列中添加一个微任务。因为微任务必须等到当前执行中的宏任务执行完毕才能被执行，所以`promise1`和`promise2`会晚于`script end`输出。又因为微任务总是先于下一个宏任务执行，所以`promise1`和`promise2`又先于`setTimeout`输出。

所以：

```javascript
//这一整段代码是一个宏任务
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');	// 产生一个新的宏任务放到宏任务队列
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');	//产生一个新的微任务放到微任务队列
}).then(function() {
  console.log('promise2');	// 产生另一个微任务并被放到微任务队列
});

/*
 当前宏任务执行完之后就会去检查微任务队列并执行微任务，微任务队列执行空了之后，再去执行下一个宏任务
*/
```

#### 为什么有些浏览器表现的不一样？

有些浏览器输出日志是这样的`script start`，`script end`，`setTimeout`，`promise1`，`promise2`。这些浏览器会在`setTimeout`之后执行promise的回调，看起来像是它们把promise回调作为了一个宏任务处理而不是微任务。

promise被当成宏任务也有情可原，毕竟promise来自于ECMAScript而不是HTML。ECMAScript规范中有'Job'的概念，和微任务有点类似，但两者的关系并不明朗，在[这里](https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16)有一些讨论。但是通常情况下，把promise当成微任务来处理还是更加妥当的。

把promise当成宏任务处理会引起一些问题。例如，回调会被宏任务结束后的页面渲染或其他事情推迟，也会因为和其他宏任务源的交互产生执行上的不确定性，又或者会影响其他API的调用，等等。

这里有个Edge中把promise当成微任务处理的[投票](https://connect.microsoft.com/IE/feedback/details/1658365)，Webkit正在做正确的事情，所以我觉得Safari最终也会修改已有的执行机制。而且在Firefox43中这已经是被修复了的。

#### 如何分辨一个任务是宏任务还是微任务

实际测试是一种办法。看日志输出相对promise和`setTimeout`的位置，前提是你所依赖的实现是正确的。

另一个方法是查规范。例如，[这里](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)提到了`setTimeout`是一个宏任务，而在[这里](https://dom.spec.whatwg.org/#queue-a-mutation-record)提到了mutation会产生一个微任务。

在ECMAScript中，微任务被称作'Job'。[这里](http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen)提到，`PerformPromiseThen`、`EnqueJob`都会产生一个微任务。

下面我们看一些更复杂的例子。。。

### Level1神仙打架

页面上有下面这么个结构

```HTML
<div class="outer">
  <div class="inner"></div>
</div>
```

Js代码如下，当点击页面元素时，控制台会如何输出？

```javascript
// Let's get hold of those elements
var outer = document.querySelector('.outer');
var inner = document.querySelector('.inner');

// Let's listen for attribute changes on the
// outer element
new MutationObserver(function() {
  console.log('mutate');
}).observe(outer, {
  attributes: true
});

// Here's a click listener…
function onClick() {
  console.log('click');

  setTimeout(function() {
    console.log('timeout');
  }, 0);

  Promise.resolve().then(function() {
    console.log('promise');
  });

  outer.setAttribute('data-random', Math.random());
}

// …which we'll attach to both elements
inner.addEventListener('click', onClick);
outer.addEventListener('click', onClick);
```

