### 宏任务和微任务

[原文链接](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

（译者：第一段是废话，不译）

如果你更喜欢看视频的话，这里有[Philip Roberts](https://twitter.com/philip_roberts)讲述的一个[视频](https://vimeo.com/96425312)----视频里并没有讲微任务，但对宏任务、队列和调度进行了很棒的介绍。好了，话不多说，开始我们的旅程...

先看一段小代码：

```javascript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout')
}, 0);

Promise.resolve().then(function(){
  console.log('promise1');
}).then(function() {
  console.log('promise2');
})

console.log('script end');
```

#### 上面代码执行的结果输出顺序是什么？

正确答案是：`script start`,`script end`,`promise1`,`promise2`,`setTimeout`。

事实不同浏览器有不同的结果。Edge，Firefox 40， iOS Safari和desktop Safari 8.0.8输出的结果中，`setTimeout`先于`promise1`和`promise2`输出，而在Firefox 39和Safari 8.0.7中输出结果又是正常的。

#### 为什么是这样的？

要知道为什么首先要知道事件循环（event loop）是如何处理宏任务和微任务的。如果你是第一次知道这些概念，那么你可能会觉得有些难以理解，不过别怕，深呼吸，发车。。。。

每个进程都有自己的“事件循环”，包括web worker在内也是，所以它们可以独立运行。在同一个页面中的程序共享着同一个事件循环，它们因此能够同步的进行交流。事件循环持续的运行，不断执行存在于任务队列中的任务。一个事件循环有多个任务源，一个任务源就是包含多个任务的列表，根据列表中任务的顺序，来调度任务。对于浏览器来讲，浏览器需要决定每次循环时任务从哪个任务源中取，这使得浏览器能够给予视觉敏感的任务一些优先权，比如用户输入。好，各位跟紧了。。。

宏任务可以被调度，所以浏览器可以把宏任务按照一定的顺序的放到js作用域或者DOM中去执行。在执行任务中间，浏览器可能会去更新页面。从鼠标点击到事件回调被执行，这需要一个宏任务来完成，比如渲染HTML，或者上面例子中的`setTimeout`。

`setTimeout`会等待一个延迟时间，然后再去调度包含它回调的宏任务来执行。所以上面例子中，`setTimeout`会比`script end`后输出。`script end`的输出与`setTimeout`回调的执行不属于同一任务。

微任务（microtasks）通常指那些应当在当前执行的脚本执行完毕后（当js执行栈为空时）执行的任务，比如一系列动作的响应，或者没有副作用的异步回调。在宏任务执行结束，没有其他js代码在执行时，微任务队列中的任务就会被处理。在微任务处理过程中加入的其他微任务会被放到队列尾部，并且也会一起被处理。微任务包括 mutaion observer回调（MutaionObserver用来观察节点的变化的），还有比如上面例子中的promise回调。

一个promise被创建后，就会为自己的回调设置一个微任务放到微任务队列中，这确保了它的回调是被异步执行的。所以在一个promise后面调用`.then(yey,nay)`会立即向微任务队列中添加一个微任务。因为微任务必须等到当前执行中的宏任务执行完毕才能被执行，所以`promise1`和`promise2`会晚于`script end`输出。又因为微任务总是先于下一个宏任务执行，所以`promise1`和`promise2`又先于`setTimeout`输出。

所以：

```javascript
//这一整段代码是一个宏任务
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');	// 产生一个新的宏任务放到宏任务队列
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');	//产生一个新的微任务放到微任务队列
}).then(function() {
  console.log('promise2');	// 产生另一个微任务并被放到微任务队列
});

/*
 当前宏任务执行完之后就会去检查微任务队列并执行微任务，微任务队列执行空了之后，再去执行下一个宏任务
*/
```

#### 为什么有些浏览器表现的不一样？

